rm(list = ls())
require(formatR)
require(stringr)
require(stringi)
sPathRoot = "C:/Users/Christoph/Documents/GitHub/BCS/BCS"
setwd(sPathRoot)
lQEs = list.dirs(path = ".")
lQEs = lQEs[grep("BCS_", lQEs, fixed = T)]
iNbQEs = length(lQEs)
iNbQEs
iCounterQEs = 1
sFile = paste(sPathFile = sub('./', '', lQEs[iCounterQEs]), '.r', sep ='')
sFile
setwd(paste(sPathRoot, sub('./', '', lQEs[iCounterQEs]), sep = '/', collapse = ''))
tidy_source(source = sFile, comments = TRUE, indent = 4)
tidy_source(source = sFile, comments = TRUE, indent = 4)
?tidy_source
# Cleaning up all quantlets in a folder
rm(list = ls())
require(formatR)
require(stringr)
require(stringi)
sPathRoot = "C:/Users/Christoph/Documents/GitHub/BCS/BCS"
setwd(sPathRoot)
lQEs = list.dirs(path = ".")
lQEs = lQEs[grep("BCS_", lQEs, fixed = T)]
iNbQEs = length(lQEs)
for(iCounterQEs in 1:iNbQEs){
sFile = paste(sPathFile = sub('./', '', lQEs[iCounterQEs]), '.r', sep ='')
setwd(paste(sPathRoot, sub('./', '', lQEs[iCounterQEs]), sep = '/', collapse = ''))
tidy_source(source = sFile, comments = TRUE, indent = 4, file = sFile)
close(file(sFile))
}
iCounterQEs
for(iCounterQEs in 60:iNbQEs){
sFile = paste(sPathFile = sub('./', '', lQEs[iCounterQEs]), '.r', sep ='')
setwd(paste(sPathRoot, sub('./', '', lQEs[iCounterQEs]), sep = '/', collapse = ''))
tidy_source(source = sFile, comments = TRUE, indent = 4, file = sFile)
close(file(sFile))
}
library(copula)
graphics.off()
layout(matrix(c(1, 2, 3, 4, 5, 6), 3, 2, byrow = TRUE))  # defines number of plots and their respective positions
par(pty = "s", mar = c(2.1, 2.5, 2.1, 2.5))  # graphical parameters see ?par()
# Gumbel Copulae with theta=2
# Gumbel Copula for normal marginal distributions
gumMVD <- mvdc(gumbelCopula(2), margins = c("norm", "norm"), paramMargins = list(list(mean = 0, sd = 1.2), list(mean = 0,
sd = 1.2)))  # marginal distribution parameters
# Contour Plot: Gumbel Copula based on normal marginal distributions
contour(gumMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), cex.axis = 1.5, labcex = 1.5, lwd = 3)  # random variables
# Gumbel Copula for t6 marginal distributions
gumMVD <- mvdc(gumbelCopula(2), margins = c("t", "t"), paramMargins = list(list(df = 6), list(df = 6)))  # marginal distribution parameter
# Contour Plot: Gumbel Copula based on t6 marginal distributions
contour(gumMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), cex.axis = 1.5, labcex = 1.5, lwd = 3)
# Clayton Copulae theta=2
# Clayton Copula for normal marginal distributions
clayMVD <- mvdc(claytonCopula(2), margins = c("norm", "norm"), paramMargins = list(list(mean = 0, sd = 1.2), list(mean = 0,
sd = 1.2)))
# Contour Plot: Clayton Copula for normal marginal distributions
contour(clayMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), cex.axis = 1.5, labcex = 1.5, lwd = 3)
# Clayton Copula for t6 marginal distributions
clayMVD <- mvdc(claytonCopula(2), margins = c("t", "t"), paramMargins = list(list(df = 6), list(df = 6)))
# Contour Plot: Clayton Copula for t6 marginal distributions
contour(clayMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), cex.axis = 1.5, labcex = 1.5, lwd = 3)
# Frank Copulae theta=2
# Frank Copula for normal marginal distributions
frankMVD <- mvdc(frankCopula(2), margins = c("norm", "norm"), paramMargins = list(list(mean = 0, sd = 1.2), list(mean = 0,
sd = 1.2)))
# Contour Plot: Frank Copula for normal marginal distributions
contour(frankMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), nlevels = 10, cex.axis = 1.5, labcex = 1.5, lwd = 3)
# Frank Copula for t6 marginal distributions
frankMVD <- mvdc(frankCopula(2), margins = c("t", "t"), paramMargins = list(list(df = 6), list(df = 6)))
# Contour Plot: Frank Copula for t6 marginal distributions
contour(frankMVD, dMvdc, xlim = c(-2.5, 2.5), ylim = c(-2.5, 2.5), nlevels = 10, cex.axis = 1.5, labcex = 1.5, lwd = 3)
library("cluster")  # load package for cluster analysis
data("agriculture", package = "cluster")  # load the data
mydata = scale(agriculture)  # normalize the data
d = dist(mydata, method = "euclidean")  # calculate distance matrix
print(d, digits = 2)  # show distance matrix
fit = hclust(d, method = "ward")  # fit the model
dev.new()
plot(fit, main = "", , sub = "", xlab = "", ylab = "Euclidean distance")  # plot the solution
groups = cutree(fit, k = 5)  # define clusters
rect.hclust(fit, k = 5, border = "red")  # draw boxes
library("cluster")  # install package for cluster analysis
data("agriculture", package = "cluster")  # load the data
mydata = scale(agriculture)  # normalize the data
d = dist(mydata, method = "euclidean")  # calculate distance matrix
print(d, digits = 2)  # show distance matrix
dev.new()
par(mfrow = c(1, 3))  # draw 3 differents methods in one plot
plot(hclust(d, method = "single"), main = "Single linkage", sub = "", xlab = "", ylab = "Euclidean distance")
plot(hclust(d, method = "complete"), main = "Complete linkage", sub = "", xlab = "", ylab = "Euclidean distance")
plot(hclust(d, method = "average"), main = "Average linkage", sub = "", xlab = "", ylab = "Euclidean distance")
